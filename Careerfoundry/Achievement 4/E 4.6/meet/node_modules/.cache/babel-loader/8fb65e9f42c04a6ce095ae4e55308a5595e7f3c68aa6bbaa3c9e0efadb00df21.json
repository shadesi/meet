{"ast":null,"code":"// src/api.js\n\nimport mockData from \"./mock-data\";\n\n/**\n * Extract locations from the events data, removing duplicates.\n * @param {*} events - array of event objects\n * @returns Array of unique locations\n */\nexport const extractLocations = events => {\n  const extractedLocations = events.map(event => event.location);\n  const locations = [...new Set(extractedLocations)];\n  return locations;\n};\n\n/**\n * Get the access token from localStorage or redirect to Google authorization.\n * @returns Promise resolving to the access token\n */\nexport const getAccessToken = async () => {\n  const accessToken = localStorage.getItem('access_token');\n  const tokenCheck = accessToken && (await checkToken(accessToken));\n  if (!accessToken || tokenCheck.error) {\n    await localStorage.removeItem(\"access_token\");\n    const searchParams = new URLSearchParams(window.location.search);\n    const code = searchParams.get(\"code\");\n    if (!code) {\n      const response = await fetch(\"YOUR_SERVERLESS_GET_AUTH_URL_ENDPOINT\");\n      const result = await response.json();\n      const {\n        authUrl\n      } = result;\n      window.location.href = authUrl;\n    } else {\n      return await getToken(code);\n    }\n  }\n  return accessToken;\n};\n\n/**\n * Check the validity of the access token.\n * @param {string} accessToken - the token to check\n * @returns Promise resolving to the token information\n */\nconst checkToken = async accessToken => {\n  const response = await fetch(`https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=${accessToken}`);\n  return await response.json();\n};\n\n/**\n * Fetch the list of events, using mock data for localhost.\n * @param {string} currentCity - the selected city\n * @param {number} currentNOE - the number of events to fetch\n * @returns Promise resolving to the array of events\n */\nexport const getEvents = async (currentCity, currentNOE) => {\n  if (window.location.href.startsWith(\"http://localhost\")) {\n    return mockData.slice(0, currentNOE); // Simulate fetching a specific number of events\n  }\n  const token = await getAccessToken();\n  if (token) {\n    removeQuery();\n    const url = `YOUR_GET_EVENTS_API_ENDPOINT/${token}?city=${currentCity}&number=${currentNOE}`; // Modify to include city and number\n    const response = await fetch(url);\n    const result = await response.json();\n    return result.events || null;\n  }\n};\n\n/**\n * Remove the query parameters from the URL.\n */\nconst removeQuery = () => {\n  let newurl;\n  if (window.history.pushState && window.location.pathname) {\n    newurl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;\n    window.history.pushState(\"\", \"\", newurl);\n  } else {\n    newurl = `${window.location.protocol}//${window.location.host}`;\n    window.history.pushState(\"\", \"\", newurl);\n  }\n};\n\n/**\n * Retrieve the access token using the provided authorization code.\n * @param {string} code - the authorization code from Google\n * @returns Promise resolving to the access token\n */\nconst getToken = async code => {\n  const encodeCode = encodeURIComponent(code);\n  const response = await fetch(`YOUR_GET_ACCESS_TOKEN_ENDPOINT/${encodeCode}`);\n  const {\n    access_token\n  } = await response.json();\n  if (access_token) {\n    localStorage.setItem(\"access_token\", access_token);\n  }\n  return access_token;\n};","map":{"version":3,"names":["mockData","extractLocations","events","extractedLocations","map","event","location","locations","Set","getAccessToken","accessToken","localStorage","getItem","tokenCheck","checkToken","error","removeItem","searchParams","URLSearchParams","window","search","code","get","response","fetch","result","json","authUrl","href","getToken","getEvents","currentCity","currentNOE","startsWith","slice","token","removeQuery","url","newurl","history","pushState","pathname","protocol","host","encodeCode","encodeURIComponent","access_token","setItem"],"sources":["/Users/shanedesilva/Desktop/Careerfoundry/Achievement 4/E 4.6/meet temp/src/api.js"],"sourcesContent":["// src/api.js\n\nimport mockData from \"./mock-data\";\n\n/**\n * Extract locations from the events data, removing duplicates.\n * @param {*} events - array of event objects\n * @returns Array of unique locations\n */\nexport const extractLocations = (events) => {\n  const extractedLocations = events.map((event) => event.location);\n  const locations = [...new Set(extractedLocations)];\n  return locations;\n};\n\n/**\n * Get the access token from localStorage or redirect to Google authorization.\n * @returns Promise resolving to the access token\n */\nexport const getAccessToken = async () => {\n  const accessToken = localStorage.getItem('access_token');\n  const tokenCheck = accessToken && (await checkToken(accessToken));\n\n  if (!accessToken || tokenCheck.error) {\n    await localStorage.removeItem(\"access_token\");\n    const searchParams = new URLSearchParams(window.location.search);\n    const code = searchParams.get(\"code\");\n\n    if (!code) {\n      const response = await fetch(\"YOUR_SERVERLESS_GET_AUTH_URL_ENDPOINT\");\n      const result = await response.json();\n      const { authUrl } = result;\n      window.location.href = authUrl;\n    } else {\n      return await getToken(code);\n    }\n  }\n  return accessToken;\n};\n\n/**\n * Check the validity of the access token.\n * @param {string} accessToken - the token to check\n * @returns Promise resolving to the token information\n */\nconst checkToken = async (accessToken) => {\n  const response = await fetch(`https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=${accessToken}`);\n  return await response.json();\n};\n\n/**\n * Fetch the list of events, using mock data for localhost.\n * @param {string} currentCity - the selected city\n * @param {number} currentNOE - the number of events to fetch\n * @returns Promise resolving to the array of events\n */\nexport const getEvents = async (currentCity, currentNOE) => {\n  if (window.location.href.startsWith(\"http://localhost\")) {\n    return mockData.slice(0, currentNOE); // Simulate fetching a specific number of events\n  }\n\n  const token = await getAccessToken();\n  if (token) {\n    removeQuery();\n    const url = `YOUR_GET_EVENTS_API_ENDPOINT/${token}?city=${currentCity}&number=${currentNOE}`; // Modify to include city and number\n    const response = await fetch(url);\n    const result = await response.json();\n    return result.events || null;\n  }\n};\n\n/**\n * Remove the query parameters from the URL.\n */\nconst removeQuery = () => {\n  let newurl;\n  if (window.history.pushState && window.location.pathname) {\n    newurl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;\n    window.history.pushState(\"\", \"\", newurl);\n  } else {\n    newurl = `${window.location.protocol}//${window.location.host}`;\n    window.history.pushState(\"\", \"\", newurl);\n  }\n};\n\n/**\n * Retrieve the access token using the provided authorization code.\n * @param {string} code - the authorization code from Google\n * @returns Promise resolving to the access token\n */\nconst getToken = async (code) => {\n  const encodeCode = encodeURIComponent(code);\n  const response = await fetch(`YOUR_GET_ACCESS_TOKEN_ENDPOINT/${encodeCode}`);\n  const { access_token } = await response.json();\n  if (access_token) {\n    localStorage.setItem(\"access_token\", access_token);\n  }\n  return access_token;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}